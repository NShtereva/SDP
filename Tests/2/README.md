# Контролна работа №2

## Задача 1
Нека е дадено двоично дърво от цели числа, с възли, представени със следната структура:
```c++
struct Node
{
  int data;
  Node* left;
  Node* right;
};
```
„Растящ път“ в непразно дърво, наричаме всеки път от корена на дървото до негово листо, такъв че стойностите на последователните елемети от пътя нарастват. Да се дефинира
функция int maxPath(Node* t), където t е корен на непразно двоично дърво. Да се намери най-голямото число, което може да се получи при сумиране на елементите на някой 
нарастващ път от дървото.

Пример:
```
    1
   / \
  2   1
 /   / \
3   9   8

За даденото дърво, търсеното число е 6, което се получава като сума на елементите от пътя 1->2->3.
```

## Задача 2
Нека е дадено двоично дърво. „Усредняване на дървото“ наричаме редицата a1,...,ah, където h е височината (броя нива) на дървото, а ai е цялата част на средното 
аритметично на елементите на i-тото ниво (нивата са номерирани от корена към листата). За дървото по-долу усредняването е {1,3,5}:
```
  1        <--- ниво 1
 / \
2   5      <--- ниво 2
 \
  5        <--- ниво 3
```
При представянето от предишната задача, да се дефинира функция average, която по корен на двоично дърво, връща неговото усредняване, под формата на вектор с числа.

## Задача 3
Нека е дадено двоично дърво от символи (тип char) с възли, представни със следната структура:
```c++
struct CharNode
{
  char data;
  CharNode* left;
  CharNode* right;
};
```
„Дума“ на дървото наричаме всяка дума, която може да се получи като:
- Последователните символи по път от корена на дървото до негово листо. На примерното дърво, това са думите „cac“, „caa“ и „cac“.
- Символите на дадено ниво на дървото, прочетени отляво надясно. На примерното дърво, това са думите „c“, „aa“ и „cac“.
```
    c
   / \
  a   a
 /   / \
c   a   c
```
Да се дефинира функцията mostFrequent, която по корен на двоично дърво, намира и връща думата, която се среща най-често в него (или една от думите). За примерното дърво
това е думата „cac“, която се среща 3 пъти.
